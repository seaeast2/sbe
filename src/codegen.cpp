#include "codegen.h"
#include <iostream>
#include <stdexcept>

namespace sbe {

std::string CodeGenerator::generate(const IRModule& module) {
    output.str("");
    output.clear();
    
    // Generate assembly header
    emit(".intel_syntax noprefix");
    emit(".text");
    emit("");
    
    // Generate each function
    for (const auto& func : module.getFunctions()) {
        generateFunction(func);
        emit("");
    }
    
    return output.str();
}

void CodeGenerator::generateFunction(const IRFunction& func) {
    stackOffset = 0;
    variableOffsets.clear();
    
    // Function label
    emit(".globl " + func.name);
    emit(func.name + ":");
    
    // Prologue
    emitPrologue(func);
    
    // Generate instructions
    for (const auto& inst : func.instructions) {
        generateInstruction(inst);
    }
    
    // Epilogue is generated by RET instruction
}

void CodeGenerator::generateInstruction(const IRInstruction& inst) {
    switch (inst.opcode) {
        case IROpcode::LOAD: {
            // Load immediate value into a virtual register (use stack)
            emit("    mov DWORD PTR [rbp-" + std::to_string(stackOffset + 4) + "], " + 
                 std::to_string(inst.immediate));
            variableOffsets[inst.dest] = stackOffset + 4;
            stackOffset += 4;
            break;
        }
        
        case IROpcode::STORE: {
            // Move from source to destination
            int srcOffset = getStackOffset(inst.operand1);
            emit("    mov eax, DWORD PTR [rbp-" + std::to_string(srcOffset) + "]");
            emit("    mov DWORD PTR [rbp-" + std::to_string(stackOffset + 4) + "], eax");
            variableOffsets[inst.dest] = stackOffset + 4;
            stackOffset += 4;
            break;
        }
        
        case IROpcode::ADD: {
            int op1Offset = getStackOffset(inst.operand1);
            int op2Offset = getStackOffset(inst.operand2);
            emit("    mov eax, DWORD PTR [rbp-" + std::to_string(op1Offset) + "]");
            emit("    add eax, DWORD PTR [rbp-" + std::to_string(op2Offset) + "]");
            emit("    mov DWORD PTR [rbp-" + std::to_string(stackOffset + 4) + "], eax");
            variableOffsets[inst.dest] = stackOffset + 4;
            stackOffset += 4;
            break;
        }
        
        case IROpcode::SUB: {
            int op1Offset = getStackOffset(inst.operand1);
            int op2Offset = getStackOffset(inst.operand2);
            emit("    mov eax, DWORD PTR [rbp-" + std::to_string(op1Offset) + "]");
            emit("    sub eax, DWORD PTR [rbp-" + std::to_string(op2Offset) + "]");
            emit("    mov DWORD PTR [rbp-" + std::to_string(stackOffset + 4) + "], eax");
            variableOffsets[inst.dest] = stackOffset + 4;
            stackOffset += 4;
            break;
        }
        
        case IROpcode::MUL: {
            int op1Offset = getStackOffset(inst.operand1);
            int op2Offset = getStackOffset(inst.operand2);
            emit("    mov eax, DWORD PTR [rbp-" + std::to_string(op1Offset) + "]");
            emit("    imul eax, DWORD PTR [rbp-" + std::to_string(op2Offset) + "]");
            emit("    mov DWORD PTR [rbp-" + std::to_string(stackOffset + 4) + "], eax");
            variableOffsets[inst.dest] = stackOffset + 4;
            stackOffset += 4;
            break;
        }
        
        case IROpcode::DIV: {
            int op1Offset = getStackOffset(inst.operand1);
            int op2Offset = getStackOffset(inst.operand2);
            emit("    mov eax, DWORD PTR [rbp-" + std::to_string(op1Offset) + "]");
            emit("    cdq");  // Sign extend eax to edx:eax
            emit("    idiv DWORD PTR [rbp-" + std::to_string(op2Offset) + "]");
            emit("    mov DWORD PTR [rbp-" + std::to_string(stackOffset + 4) + "], eax");
            variableOffsets[inst.dest] = stackOffset + 4;
            stackOffset += 4;
            break;
        }
        
        case IROpcode::RET: {
            // Load return value into eax
            if (!inst.operand1.empty()) {
                int retOffset = getStackOffset(inst.operand1);
                emit("    mov eax, DWORD PTR [rbp-" + std::to_string(retOffset) + "]");
            }
            emitEpilogue();
            emit("    ret");
            break;
        }
    }
}

void CodeGenerator::emitPrologue(const IRFunction&) {
    emit("    push rbp");
    emit("    mov rbp, rsp");
    emit("    sub rsp, " + std::to_string(STACK_FRAME_SIZE));
}

void CodeGenerator::emitEpilogue() {
    emit("    mov rsp, rbp");
    emit("    pop rbp");
}

int CodeGenerator::getStackOffset(const std::string& var) {
    auto it = variableOffsets.find(var);
    if (it != variableOffsets.end()) {
        return it->second;
    }
    // Variable not found - this indicates a bug in IR generation
    throw std::runtime_error("Variable '" + var + "' not found in stack allocation");
}

void CodeGenerator::emit(const std::string& line) {
    output << line << "\n";
}

} // namespace sbe
